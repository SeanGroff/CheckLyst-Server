import { GraphQLResolveInfo, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaBindingClass, BasePrismaOptions, Options } from "prisma-lib";
import { typeDefs } from "./graphql";
// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  activity: (where?: ActivityWhereInput) => Promise<boolean>;
  checkLyst: (where?: CheckLystWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  label: (where?: LabelWhereInput) => Promise<boolean>;
  templateLyst: (where?: TemplateLystWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $delegate: Delegate;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  activity: <T = Activity>(
    where: ActivityWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  activities: <T = Promise<Array<ActivityNode>>>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  activitiesConnection: <T = ActivityConnection>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  checkLyst: <T = CheckLyst>(
    where: CheckLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  checkLysts: <T = Promise<Array<CheckLystNode>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  checkLystsConnection: <T = CheckLystConnection>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  item: <T = Item>(
    where: ItemWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  items: <T = Promise<Array<ItemNode>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  itemsConnection: <T = ItemConnection>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  label: <T = Label>(
    where: LabelWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  labels: <T = Promise<Array<LabelNode>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  labelsConnection: <T = LabelConnection>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  templateLyst: <T = TemplateLyst>(
    where: TemplateLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  templateLysts: <T = Promise<Array<TemplateLystNode>>>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  templateLystsConnection: <T = TemplateLystConnection>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  team: <T = Team>(
    where: TeamWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  teams: <T = Promise<Array<TeamNode>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  teamsConnection: <T = TeamConnection>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  user: <T = User>(
    where: UserWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  users: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  usersConnection: <T = UserConnection>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  node: <T = Node>(args: { id: ID_Output }, fragment?: string | Object) => T;

  /**
   * Mutations
   */

  createActivity: <T = Activity>(
    data: ActivityCreateInput,
    fragment?: string | Object
  ) => T;
  updateActivity: <T = Activity>(
    args: { data: ActivityUpdateInput; where: ActivityWhereUniqueInput },
    fragment?: string | Object
  ) => T;
  updateManyActivities: <T = BatchPayload>(
    args: { data: ActivityUpdateInput; where?: ActivityWhereInput },
    fragment?: string | Object
  ) => T;
  upsertActivity: <T = Activity>(
    args: {
      where: ActivityWhereUniqueInput;
      create: ActivityCreateInput;
      update: ActivityUpdateInput;
    },
    fragment?: string | Object
  ) => T;
  deleteActivity: <T = Activity>(
    where: ActivityWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyActivities: <T = BatchPayload>(
    where?: ActivityWhereInput,
    fragment?: string | Object
  ) => T;
  createCheckLyst: <T = CheckLyst>(
    data: CheckLystCreateInput,
    fragment?: string | Object
  ) => T;
  updateCheckLyst: <T = CheckLyst>(
    args: { data: CheckLystUpdateInput; where: CheckLystWhereUniqueInput },
    fragment?: string | Object
  ) => T;
  updateManyCheckLysts: <T = BatchPayload>(
    args: { data: CheckLystUpdateInput; where?: CheckLystWhereInput },
    fragment?: string | Object
  ) => T;
  upsertCheckLyst: <T = CheckLyst>(
    args: {
      where: CheckLystWhereUniqueInput;
      create: CheckLystCreateInput;
      update: CheckLystUpdateInput;
    },
    fragment?: string | Object
  ) => T;
  deleteCheckLyst: <T = CheckLyst>(
    where: CheckLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyCheckLysts: <T = BatchPayload>(
    where?: CheckLystWhereInput,
    fragment?: string | Object
  ) => T;
  createItem: <T = Item>(
    data: ItemCreateInput,
    fragment?: string | Object
  ) => T;
  updateItem: <T = Item>(
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput },
    fragment?: string | Object
  ) => T;
  updateManyItems: <T = BatchPayload>(
    args: { data: ItemUpdateInput; where?: ItemWhereInput },
    fragment?: string | Object
  ) => T;
  upsertItem: <T = Item>(
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    },
    fragment?: string | Object
  ) => T;
  deleteItem: <T = Item>(
    where: ItemWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyItems: <T = BatchPayload>(
    where?: ItemWhereInput,
    fragment?: string | Object
  ) => T;
  createLabel: <T = Label>(
    data: LabelCreateInput,
    fragment?: string | Object
  ) => T;
  updateLabel: <T = Label>(
    args: { data: LabelUpdateInput; where: LabelWhereUniqueInput },
    fragment?: string | Object
  ) => T;
  updateManyLabels: <T = BatchPayload>(
    args: { data: LabelUpdateInput; where?: LabelWhereInput },
    fragment?: string | Object
  ) => T;
  upsertLabel: <T = Label>(
    args: {
      where: LabelWhereUniqueInput;
      create: LabelCreateInput;
      update: LabelUpdateInput;
    },
    fragment?: string | Object
  ) => T;
  deleteLabel: <T = Label>(
    where: LabelWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyLabels: <T = BatchPayload>(
    where?: LabelWhereInput,
    fragment?: string | Object
  ) => T;
  createTemplateLyst: <T = TemplateLyst>(
    data: TemplateLystCreateInput,
    fragment?: string | Object
  ) => T;
  updateTemplateLyst: <T = TemplateLyst>(
    args: {
      data: TemplateLystUpdateInput;
      where: TemplateLystWhereUniqueInput;
    },
    fragment?: string | Object
  ) => T;
  updateManyTemplateLysts: <T = BatchPayload>(
    args: { data: TemplateLystUpdateInput; where?: TemplateLystWhereInput },
    fragment?: string | Object
  ) => T;
  upsertTemplateLyst: <T = TemplateLyst>(
    args: {
      where: TemplateLystWhereUniqueInput;
      create: TemplateLystCreateInput;
      update: TemplateLystUpdateInput;
    },
    fragment?: string | Object
  ) => T;
  deleteTemplateLyst: <T = TemplateLyst>(
    where: TemplateLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyTemplateLysts: <T = BatchPayload>(
    where?: TemplateLystWhereInput,
    fragment?: string | Object
  ) => T;
  createTeam: <T = Team>(
    data: TeamCreateInput,
    fragment?: string | Object
  ) => T;
  updateTeam: <T = Team>(
    args: { data: TeamUpdateInput; where: TeamWhereUniqueInput },
    fragment?: string | Object
  ) => T;
  updateManyTeams: <T = BatchPayload>(
    args: { data: TeamUpdateInput; where?: TeamWhereInput },
    fragment?: string | Object
  ) => T;
  upsertTeam: <T = Team>(
    args: {
      where: TeamWhereUniqueInput;
      create: TeamCreateInput;
      update: TeamUpdateInput;
    },
    fragment?: string | Object
  ) => T;
  deleteTeam: <T = Team>(
    where: TeamWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyTeams: <T = BatchPayload>(
    where?: TeamWhereInput,
    fragment?: string | Object
  ) => T;
  createUser: <T = User>(
    data: UserCreateInput,
    fragment?: string | Object
  ) => T;
  updateUser: <T = User>(
    args: { data: UserUpdateInput; where: UserWhereUniqueInput },
    fragment?: string | Object
  ) => T;
  updateManyUsers: <T = BatchPayload>(
    args: { data: UserUpdateInput; where?: UserWhereInput },
    fragment?: string | Object
  ) => T;
  upsertUser: <T = User>(
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    },
    fragment?: string | Object
  ) => T;
  deleteUser: <T = User>(
    where: UserWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyUsers: <T = BatchPayload>(
    where?: UserWhereInput,
    fragment?: string | Object
  ) => T;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activity: <T = ActivitySubscriptionPayloadSubscription>(
    where?: ActivitySubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  checkLyst: <T = CheckLystSubscriptionPayloadSubscription>(
    where?: CheckLystSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  item: <T = ItemSubscriptionPayloadSubscription>(
    where?: ItemSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  label: <T = LabelSubscriptionPayloadSubscription>(
    where?: LabelSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  templateLyst: <T = TemplateLystSubscriptionPayloadSubscription>(
    where?: TemplateLystSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  team: <T = TeamSubscriptionPayloadSubscription>(
    where?: TeamSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  user: <T = UserSubscriptionPayloadSubscription>(
    where?: UserSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
}

export interface Delegate {
  (
    operation: "query" | "mutation",
    fieldName: string,
    args: {
      [key: string]: any;
    },
    infoOrQuery?: GraphQLResolveInfo,
    options?: Options
  ): Promise<any>;
  query: DelegateQuery;
  mutation: DelegateMutation;
  subscription: DelegateSubscription;
}

export interface DelegateQuery {
  activity: <T = Promise<Partial<ActivityNode | null>>>(
    where: ActivityWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  activities: <T = Promise<Array<ActivityNode>>>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  activitiesConnection: <T = Promise<Partial<ActivityConnectionNode>>>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  checkLyst: <T = Promise<Partial<CheckLystNode | null>>>(
    where: CheckLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  checkLysts: <T = Promise<Array<CheckLystNode>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  checkLystsConnection: <T = Promise<Partial<CheckLystConnectionNode>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  item: <T = Promise<Partial<ItemNode | null>>>(
    where: ItemWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  items: <T = Promise<Array<ItemNode>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  itemsConnection: <T = Promise<Partial<ItemConnectionNode>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  label: <T = Promise<Partial<LabelNode | null>>>(
    where: LabelWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  labels: <T = Promise<Array<LabelNode>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  labelsConnection: <T = Promise<Partial<LabelConnectionNode>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  templateLyst: <T = Promise<Partial<TemplateLystNode | null>>>(
    where: TemplateLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  templateLysts: <T = Promise<Array<TemplateLystNode>>>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  templateLystsConnection: <T = Promise<Partial<TemplateLystConnectionNode>>>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  team: <T = Promise<Partial<TeamNode | null>>>(
    where: TeamWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  teams: <T = Promise<Array<TeamNode>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  teamsConnection: <T = Promise<Partial<TeamConnectionNode>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  user: <T = Promise<Partial<UserNode | null>>>(
    where: UserWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  users: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  usersConnection: <T = Promise<Partial<UserConnectionNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  node: <T = Promise<Partial<NodeNode | null>>>(
    args: { id: ID_Output },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
}

export interface DelegateMutation {
  createActivity: <T = Promise<Partial<ActivityNode>>>(
    where: ActivityCreateInput,
    fragment?: string | Object
  ) => T;
  updateActivity: <T = Promise<Partial<ActivityNode | null>>>(
    args: { data: ActivityUpdateInput; where: ActivityWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyActivities: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: ActivityUpdateInput; where?: ActivityWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertActivity: <T = Promise<Partial<ActivityNode>>>(
    args: {
      where: ActivityWhereUniqueInput;
      create: ActivityCreateInput;
      update: ActivityUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteActivity: <T = Promise<Partial<ActivityNode | null>>>(
    where: ActivityWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyActivities: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: ActivityWhereInput,
    fragment?: string | Object
  ) => T;
  createCheckLyst: <T = Promise<Partial<CheckLystNode>>>(
    where: CheckLystCreateInput,
    fragment?: string | Object
  ) => T;
  updateCheckLyst: <T = Promise<Partial<CheckLystNode | null>>>(
    args: { data: CheckLystUpdateInput; where: CheckLystWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyCheckLysts: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: CheckLystUpdateInput; where?: CheckLystWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertCheckLyst: <T = Promise<Partial<CheckLystNode>>>(
    args: {
      where: CheckLystWhereUniqueInput;
      create: CheckLystCreateInput;
      update: CheckLystUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteCheckLyst: <T = Promise<Partial<CheckLystNode | null>>>(
    where: CheckLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyCheckLysts: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: CheckLystWhereInput,
    fragment?: string | Object
  ) => T;
  createItem: <T = Promise<Partial<ItemNode>>>(
    where: ItemCreateInput,
    fragment?: string | Object
  ) => T;
  updateItem: <T = Promise<Partial<ItemNode | null>>>(
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyItems: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: ItemUpdateInput; where?: ItemWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertItem: <T = Promise<Partial<ItemNode>>>(
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteItem: <T = Promise<Partial<ItemNode | null>>>(
    where: ItemWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyItems: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: ItemWhereInput,
    fragment?: string | Object
  ) => T;
  createLabel: <T = Promise<Partial<LabelNode>>>(
    where: LabelCreateInput,
    fragment?: string | Object
  ) => T;
  updateLabel: <T = Promise<Partial<LabelNode | null>>>(
    args: { data: LabelUpdateInput; where: LabelWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyLabels: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: LabelUpdateInput; where?: LabelWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertLabel: <T = Promise<Partial<LabelNode>>>(
    args: {
      where: LabelWhereUniqueInput;
      create: LabelCreateInput;
      update: LabelUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteLabel: <T = Promise<Partial<LabelNode | null>>>(
    where: LabelWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyLabels: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: LabelWhereInput,
    fragment?: string | Object
  ) => T;
  createTemplateLyst: <T = Promise<Partial<TemplateLystNode>>>(
    where: TemplateLystCreateInput,
    fragment?: string | Object
  ) => T;
  updateTemplateLyst: <T = Promise<Partial<TemplateLystNode | null>>>(
    args: {
      data: TemplateLystUpdateInput;
      where: TemplateLystWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyTemplateLysts: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: TemplateLystUpdateInput; where?: TemplateLystWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertTemplateLyst: <T = Promise<Partial<TemplateLystNode>>>(
    args: {
      where: TemplateLystWhereUniqueInput;
      create: TemplateLystCreateInput;
      update: TemplateLystUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteTemplateLyst: <T = Promise<Partial<TemplateLystNode | null>>>(
    where: TemplateLystWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyTemplateLysts: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: TemplateLystWhereInput,
    fragment?: string | Object
  ) => T;
  createTeam: <T = Promise<Partial<TeamNode>>>(
    where: TeamCreateInput,
    fragment?: string | Object
  ) => T;
  updateTeam: <T = Promise<Partial<TeamNode | null>>>(
    args: { data: TeamUpdateInput; where: TeamWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyTeams: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: TeamUpdateInput; where?: TeamWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertTeam: <T = Promise<Partial<TeamNode>>>(
    args: {
      where: TeamWhereUniqueInput;
      create: TeamCreateInput;
      update: TeamUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteTeam: <T = Promise<Partial<TeamNode | null>>>(
    where: TeamWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyTeams: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: TeamWhereInput,
    fragment?: string | Object
  ) => T;
  createUser: <T = Promise<Partial<UserNode>>>(
    where: UserCreateInput,
    fragment?: string | Object
  ) => T;
  updateUser: <T = Promise<Partial<UserNode | null>>>(
    args: { data: UserUpdateInput; where: UserWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyUsers: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: UserUpdateInput; where?: UserWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertUser: <T = Promise<Partial<UserNode>>>(
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteUser: <T = Promise<Partial<UserNode | null>>>(
    where: UserWhereUniqueInput,
    fragment?: string | Object
  ) => T;
  deleteManyUsers: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: UserWhereInput,
    fragment?: string | Object
  ) => T;
}

export interface DelegateSubscription {
  activity: <
    T = Promise<AsyncIterator<Partial<ActivitySubscriptionPayloadNode | null>>>
  >(
    where?: ActivitySubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  checkLyst: <
    T = Promise<AsyncIterator<Partial<CheckLystSubscriptionPayloadNode | null>>>
  >(
    where?: CheckLystSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  item: <
    T = Promise<AsyncIterator<Partial<ItemSubscriptionPayloadNode | null>>>
  >(
    where?: ItemSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  label: <
    T = Promise<AsyncIterator<Partial<LabelSubscriptionPayloadNode | null>>>
  >(
    where?: LabelSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  templateLyst: <
    T = Promise<
      AsyncIterator<Partial<TemplateLystSubscriptionPayloadNode | null>>
    >
  >(
    where?: TemplateLystSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  team: <
    T = Promise<AsyncIterator<Partial<TeamSubscriptionPayloadNode | null>>>
  >(
    where?: TeamSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
  user: <
    T = Promise<AsyncIterator<Partial<UserSubscriptionPayloadNode | null>>>
  >(
    where?: UserSubscriptionWhereInput,
    fragment?: string | Object
  ) => T;
}

export interface BindingConstructor<T> {
  new (options?: BasePrismaOptions): T;
}

/**
 * Types
 */

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "itemsCompleted_ASC"
  | "itemsCompleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Color = "BLUE" | "GREEN" | "PINK" | "ORANGE" | "PURPLE";

export type CheckLystOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "completed_ASC"
  | "completed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "itemsCompleted_ASC"
  | "itemsCompleted_DESC"
  | "pro_ASC"
  | "pro_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type TemplateLystOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "color_ASC"
  | "color_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivityType = "CREATE" | "EDIT" | "DELETE" | "COMPLETE";

export interface ItemUpdateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  update?:
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput;
}

export type ActivityWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface TeamCreateInput {
  name: String;
  owner: UserCreateOneInput;
  admins?: UserCreateManyInput;
  creators?: UserCreateManyInput;
  users?: UserCreateManyInput;
  logo?: String;
  checkLysts?: CheckLystCreateManyWithoutTeamsInput;
  templateLysts?: TemplateLystCreateManyWithoutTeamsInput;
  itemsCompleted?: Int;
  activityLogs?: ActivityCreateManyInput;
}

export interface TeamUpsertWithWhereUniqueWithoutTemplateLystsInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutTemplateLystsDataInput;
  create: TeamCreateWithoutTemplateLystsInput;
}

export interface CheckLystCreateManyWithoutTeamsInput {
  create?:
    | CheckLystCreateWithoutTeamsInput[]
    | CheckLystCreateWithoutTeamsInput;
  connect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
}

export interface ActivityUpdateWithoutCheckLystDataInput {
  type?: ActivityType;
  user?: UserUpdateOneInput;
}

export interface CheckLystCreateWithoutTeamsInput {
  name: String;
  items?: ItemCreateManyInput;
  createdBy: UserCreateOneInput;
  users?: UserCreateManyWithoutCheckLystsInput;
  activityLog?: ActivityCreateManyWithoutCheckLystInput;
  label?: LabelCreateOneWithoutCheckLystsInput;
}

export interface TeamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  owner?: UserWhereInput;
  admins_every?: UserWhereInput;
  admins_some?: UserWhereInput;
  admins_none?: UserWhereInput;
  creators_every?: UserWhereInput;
  creators_some?: UserWhereInput;
  creators_none?: UserWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  logo?: String;
  logo_not?: String;
  logo_in?: String[] | String;
  logo_not_in?: String[] | String;
  logo_lt?: String;
  logo_lte?: String;
  logo_gt?: String;
  logo_gte?: String;
  logo_contains?: String;
  logo_not_contains?: String;
  logo_starts_with?: String;
  logo_not_starts_with?: String;
  logo_ends_with?: String;
  logo_not_ends_with?: String;
  checkLysts_every?: CheckLystWhereInput;
  checkLysts_some?: CheckLystWhereInput;
  checkLysts_none?: CheckLystWhereInput;
  templateLysts_every?: TemplateLystWhereInput;
  templateLysts_some?: TemplateLystWhereInput;
  templateLysts_none?: TemplateLystWhereInput;
  itemsCompleted?: Int;
  itemsCompleted_not?: Int;
  itemsCompleted_in?: Int[] | Int;
  itemsCompleted_not_in?: Int[] | Int;
  itemsCompleted_lt?: Int;
  itemsCompleted_lte?: Int;
  itemsCompleted_gt?: Int;
  itemsCompleted_gte?: Int;
  activityLogs_every?: ActivityWhereInput;
  activityLogs_some?: ActivityWhereInput;
  activityLogs_none?: ActivityWhereInput;
  AND?: TeamWhereInput[] | TeamWhereInput;
  OR?: TeamWhereInput[] | TeamWhereInput;
  NOT?: TeamWhereInput[] | TeamWhereInput;
}

export interface UserCreateManyWithoutCheckLystsInput {
  create?:
    | UserCreateWithoutCheckLystsInput[]
    | UserCreateWithoutCheckLystsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserCreateWithoutCheckLystsInput {
  name: String;
  email: String;
  avatar?: String;
  templateLysts?: TemplateLystCreateManyWithoutUsersInput;
  itemsCompleted?: Int;
  pro?: Boolean;
  teams?: TeamCreateManyInput;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeamWhereInput;
  AND?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  OR?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  NOT?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
}

export interface TemplateLystCreateManyWithoutUsersInput {
  create?:
    | TemplateLystCreateWithoutUsersInput[]
    | TemplateLystCreateWithoutUsersInput;
  connect?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
}

export interface ItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  completed?: Boolean;
  completed_not?: Boolean;
  completedBy?: UserWhereInput;
  AND?: ItemWhereInput[] | ItemWhereInput;
  OR?: ItemWhereInput[] | ItemWhereInput;
  NOT?: ItemWhereInput[] | ItemWhereInput;
}

export interface TemplateLystCreateWithoutUsersInput {
  name: String;
  items?: ItemCreateManyInput;
  teams?: TeamCreateManyWithoutTemplateLystsInput;
}

export interface CheckLystWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  createdBy?: UserWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  activityLog_every?: ActivityWhereInput;
  activityLog_some?: ActivityWhereInput;
  activityLog_none?: ActivityWhereInput;
  label?: LabelWhereInput;
  teams_every?: TeamWhereInput;
  teams_some?: TeamWhereInput;
  teams_none?: TeamWhereInput;
  AND?: CheckLystWhereInput[] | CheckLystWhereInput;
  OR?: CheckLystWhereInput[] | CheckLystWhereInput;
  NOT?: CheckLystWhereInput[] | CheckLystWhereInput;
}

export interface TeamCreateManyWithoutTemplateLystsInput {
  create?:
    | TeamCreateWithoutTemplateLystsInput[]
    | TeamCreateWithoutTemplateLystsInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface CheckLystSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CheckLystWhereInput;
  AND?: CheckLystSubscriptionWhereInput[] | CheckLystSubscriptionWhereInput;
  OR?: CheckLystSubscriptionWhereInput[] | CheckLystSubscriptionWhereInput;
  NOT?: CheckLystSubscriptionWhereInput[] | CheckLystSubscriptionWhereInput;
}

export interface TeamCreateWithoutTemplateLystsInput {
  name: String;
  owner: UserCreateOneInput;
  admins?: UserCreateManyInput;
  creators?: UserCreateManyInput;
  users?: UserCreateManyInput;
  logo?: String;
  checkLysts?: CheckLystCreateManyWithoutTeamsInput;
  itemsCompleted?: Int;
  activityLogs?: ActivityCreateManyInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  avatar?: String;
  checkLysts?: CheckLystUpdateManyWithoutUsersInput;
  templateLysts?: TemplateLystUpdateManyWithoutUsersInput;
  itemsCompleted?: Int;
  pro?: Boolean;
  teams?: TeamUpdateManyInput;
}

export interface ActivityCreateManyInput {
  create?: ActivityCreateInput[] | ActivityCreateInput;
  connect?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
}

export interface TemplateLystUpdateInput {
  name?: String;
  items?: ItemUpdateManyInput;
  users?: UserUpdateManyWithoutTemplateLystsInput;
  teams?: TeamUpdateManyWithoutTemplateLystsInput;
}

export interface CheckLystCreateOneWithoutActivityLogInput {
  create?: CheckLystCreateWithoutActivityLogInput;
  connect?: CheckLystWhereUniqueInput;
}

export type CheckLystWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface CheckLystCreateWithoutActivityLogInput {
  name: String;
  items?: ItemCreateManyInput;
  createdBy: UserCreateOneInput;
  users?: UserCreateManyWithoutCheckLystsInput;
  label?: LabelCreateOneWithoutCheckLystsInput;
  teams?: TeamCreateManyWithoutCheckLystsInput;
}

export interface CheckLystUpdateWithoutLabelDataInput {
  name?: String;
  items?: ItemUpdateManyInput;
  createdBy?: UserUpdateOneInput;
  users?: UserUpdateManyWithoutCheckLystsInput;
  activityLog?: ActivityUpdateManyWithoutCheckLystInput;
  teams?: TeamUpdateManyWithoutCheckLystsInput;
}

export interface ActivityUpdateInput {
  type?: ActivityType;
  user?: UserUpdateOneInput;
  checkLyst?: CheckLystUpdateOneWithoutActivityLogInput;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface LabelUpdateInput {
  user?: UserUpdateOneInput;
  checkLysts?: CheckLystUpdateManyWithoutLabelInput;
  name?: String;
  color?: Color;
}

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  avatar?: String;
  checkLysts?: CheckLystUpdateManyWithoutUsersInput;
  templateLysts?: TemplateLystUpdateManyWithoutUsersInput;
  itemsCompleted?: Int;
  pro?: Boolean;
  teams?: TeamUpdateManyInput;
}

export type LabelWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface CheckLystUpdateManyWithoutUsersInput {
  create?:
    | CheckLystCreateWithoutUsersInput[]
    | CheckLystCreateWithoutUsersInput;
  delete?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  connect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  disconnect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  update?:
    | CheckLystUpdateWithWhereUniqueWithoutUsersInput[]
    | CheckLystUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | CheckLystUpsertWithWhereUniqueWithoutUsersInput[]
    | CheckLystUpsertWithWhereUniqueWithoutUsersInput;
}

export interface LabelCreateInput {
  user: UserCreateOneInput;
  checkLysts?: CheckLystCreateManyWithoutLabelInput;
  name: String;
  color: Color;
}

export interface CheckLystUpdateWithWhereUniqueWithoutUsersInput {
  where: CheckLystWhereUniqueInput;
  data: CheckLystUpdateWithoutUsersDataInput;
}

export interface CheckLystUpdateInput {
  name?: String;
  items?: ItemUpdateManyInput;
  createdBy?: UserUpdateOneInput;
  users?: UserUpdateManyWithoutCheckLystsInput;
  activityLog?: ActivityUpdateManyWithoutCheckLystInput;
  label?: LabelUpdateOneWithoutCheckLystsInput;
  teams?: TeamUpdateManyWithoutCheckLystsInput;
}

export interface CheckLystUpdateWithoutUsersDataInput {
  name?: String;
  items?: ItemUpdateManyInput;
  createdBy?: UserUpdateOneInput;
  activityLog?: ActivityUpdateManyWithoutCheckLystInput;
  label?: LabelUpdateOneWithoutCheckLystsInput;
  teams?: TeamUpdateManyWithoutCheckLystsInput;
}

export interface CheckLystCreateInput {
  name: String;
  items?: ItemCreateManyInput;
  createdBy: UserCreateOneInput;
  users?: UserCreateManyWithoutCheckLystsInput;
  activityLog?: ActivityCreateManyWithoutCheckLystInput;
  label?: LabelCreateOneWithoutCheckLystsInput;
  teams?: TeamCreateManyWithoutCheckLystsInput;
}

export interface TemplateLystUpsertWithWhereUniqueWithoutUsersInput {
  where: TemplateLystWhereUniqueInput;
  update: TemplateLystUpdateWithoutUsersDataInput;
  create: TemplateLystCreateWithoutUsersInput;
}

export interface CheckLystUpsertWithWhereUniqueWithoutUsersInput {
  where: CheckLystWhereUniqueInput;
  update: CheckLystUpdateWithoutUsersDataInput;
  create: CheckLystCreateWithoutUsersInput;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface TeamUpsertWithWhereUniqueWithoutCheckLystsInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutCheckLystsDataInput;
  create: TeamCreateWithoutCheckLystsInput;
}

export interface ItemUpdateDataInput {
  name?: String;
  completed?: Boolean;
  completedBy?: UserUpdateOneInput;
}

export interface UserUpsertWithWhereUniqueWithoutTemplateLystsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTemplateLystsDataInput;
  create: UserCreateWithoutTemplateLystsInput;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface TeamUpsertWithWhereUniqueNestedInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface ActivityUpdateManyWithoutCheckLystInput {
  create?:
    | ActivityCreateWithoutCheckLystInput[]
    | ActivityCreateWithoutCheckLystInput;
  delete?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
  connect?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
  disconnect?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
  update?:
    | ActivityUpdateWithWhereUniqueWithoutCheckLystInput[]
    | ActivityUpdateWithWhereUniqueWithoutCheckLystInput;
  upsert?:
    | ActivityUpsertWithWhereUniqueWithoutCheckLystInput[]
    | ActivityUpsertWithWhereUniqueWithoutCheckLystInput;
}

export interface UserUpsertWithWhereUniqueWithoutCheckLystsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCheckLystsDataInput;
  create: UserCreateWithoutCheckLystsInput;
}

export interface ActivityUpdateWithWhereUniqueWithoutCheckLystInput {
  where: ActivityWhereUniqueInput;
  data: ActivityUpdateWithoutCheckLystDataInput;
}

export interface ActivityCreateInput {
  type: ActivityType;
  user: UserCreateOneInput;
  checkLyst: CheckLystCreateOneWithoutActivityLogInput;
}

export interface ActivityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: ActivityType;
  type_not?: ActivityType;
  type_in?: ActivityType[] | ActivityType;
  type_not_in?: ActivityType[] | ActivityType;
  user?: UserWhereInput;
  checkLyst?: CheckLystWhereInput;
  AND?: ActivityWhereInput[] | ActivityWhereInput;
  OR?: ActivityWhereInput[] | ActivityWhereInput;
  NOT?: ActivityWhereInput[] | ActivityWhereInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  avatar?: String;
  checkLysts?: CheckLystCreateManyWithoutUsersInput;
  templateLysts?: TemplateLystCreateManyWithoutUsersInput;
  itemsCompleted?: Int;
  pro?: Boolean;
  teams?: TeamCreateManyInput;
}

export interface ActivityUpsertWithWhereUniqueWithoutCheckLystInput {
  where: ActivityWhereUniqueInput;
  update: ActivityUpdateWithoutCheckLystDataInput;
  create: ActivityCreateWithoutCheckLystInput;
}

export interface CheckLystCreateWithoutUsersInput {
  name: String;
  items?: ItemCreateManyInput;
  createdBy: UserCreateOneInput;
  activityLog?: ActivityCreateManyWithoutCheckLystInput;
  label?: LabelCreateOneWithoutCheckLystsInput;
  teams?: TeamCreateManyWithoutCheckLystsInput;
}

export interface LabelUpdateOneWithoutCheckLystsInput {
  create?: LabelCreateWithoutCheckLystsInput;
  update?: LabelUpdateWithoutCheckLystsDataInput;
  upsert?: LabelUpsertWithoutCheckLystsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LabelWhereUniqueInput;
}

export interface ItemCreateInput {
  name: String;
  completed?: Boolean;
  completedBy?: UserCreateOneInput;
}

export interface LabelUpdateWithoutCheckLystsDataInput {
  user?: UserUpdateOneInput;
  name?: String;
  color?: Color;
}

export interface ActivityCreateWithoutCheckLystInput {
  type: ActivityType;
  user: UserCreateOneInput;
}

export interface LabelUpsertWithoutCheckLystsInput {
  update: LabelUpdateWithoutCheckLystsDataInput;
  create: LabelCreateWithoutCheckLystsInput;
}

export interface LabelCreateWithoutCheckLystsInput {
  user: UserCreateOneInput;
  name: String;
  color: Color;
}

export interface TeamUpdateManyWithoutCheckLystsInput {
  create?:
    | TeamCreateWithoutCheckLystsInput[]
    | TeamCreateWithoutCheckLystsInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutCheckLystsInput[]
    | TeamUpdateWithWhereUniqueWithoutCheckLystsInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutCheckLystsInput[]
    | TeamUpsertWithWhereUniqueWithoutCheckLystsInput;
}

export interface TeamCreateWithoutCheckLystsInput {
  name: String;
  owner: UserCreateOneInput;
  admins?: UserCreateManyInput;
  creators?: UserCreateManyInput;
  users?: UserCreateManyInput;
  logo?: String;
  templateLysts?: TemplateLystCreateManyWithoutTeamsInput;
  itemsCompleted?: Int;
  activityLogs?: ActivityCreateManyInput;
}

export interface TeamUpdateWithWhereUniqueWithoutCheckLystsInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutCheckLystsDataInput;
}

export interface TemplateLystCreateManyWithoutTeamsInput {
  create?:
    | TemplateLystCreateWithoutTeamsInput[]
    | TemplateLystCreateWithoutTeamsInput;
  connect?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
}

export interface TeamUpdateWithoutCheckLystsDataInput {
  name?: String;
  owner?: UserUpdateOneInput;
  admins?: UserUpdateManyInput;
  creators?: UserUpdateManyInput;
  users?: UserUpdateManyInput;
  logo?: String;
  templateLysts?: TemplateLystUpdateManyWithoutTeamsInput;
  itemsCompleted?: Int;
  activityLogs?: ActivityUpdateManyInput;
}

export interface UserCreateManyWithoutTemplateLystsInput {
  create?:
    | UserCreateWithoutTemplateLystsInput[]
    | UserCreateWithoutTemplateLystsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
}

export interface TeamCreateManyInput {
  create?: TeamCreateInput[] | TeamCreateInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface TemplateLystWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  teams_every?: TeamWhereInput;
  teams_some?: TeamWhereInput;
  teams_none?: TeamWhereInput;
  AND?: TemplateLystWhereInput[] | TemplateLystWhereInput;
  OR?: TemplateLystWhereInput[] | TemplateLystWhereInput;
  NOT?: TemplateLystWhereInput[] | TemplateLystWhereInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface TemplateLystSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TemplateLystWhereInput;
  AND?:
    | TemplateLystSubscriptionWhereInput[]
    | TemplateLystSubscriptionWhereInput;
  OR?:
    | TemplateLystSubscriptionWhereInput[]
    | TemplateLystSubscriptionWhereInput;
  NOT?:
    | TemplateLystSubscriptionWhereInput[]
    | TemplateLystSubscriptionWhereInput;
}

export interface TemplateLystUpdateManyWithoutTeamsInput {
  create?:
    | TemplateLystCreateWithoutTeamsInput[]
    | TemplateLystCreateWithoutTeamsInput;
  delete?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
  connect?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
  disconnect?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
  update?:
    | TemplateLystUpdateWithWhereUniqueWithoutTeamsInput[]
    | TemplateLystUpdateWithWhereUniqueWithoutTeamsInput;
  upsert?:
    | TemplateLystUpsertWithWhereUniqueWithoutTeamsInput[]
    | TemplateLystUpsertWithWhereUniqueWithoutTeamsInput;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemWhereInput;
  AND?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  OR?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  NOT?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
}

export interface TemplateLystUpdateWithWhereUniqueWithoutTeamsInput {
  where: TemplateLystWhereUniqueInput;
  data: TemplateLystUpdateWithoutTeamsDataInput;
}

export interface TeamUpdateInput {
  name?: String;
  owner?: UserUpdateOneInput;
  admins?: UserUpdateManyInput;
  creators?: UserUpdateManyInput;
  users?: UserUpdateManyInput;
  logo?: String;
  checkLysts?: CheckLystUpdateManyWithoutTeamsInput;
  templateLysts?: TemplateLystUpdateManyWithoutTeamsInput;
  itemsCompleted?: Int;
  activityLogs?: ActivityUpdateManyInput;
}

export interface TemplateLystUpdateWithoutTeamsDataInput {
  name?: String;
  items?: ItemUpdateManyInput;
  users?: UserUpdateManyWithoutTemplateLystsInput;
}

export interface CheckLystUpsertWithWhereUniqueWithoutLabelInput {
  where: CheckLystWhereUniqueInput;
  update: CheckLystUpdateWithoutLabelDataInput;
  create: CheckLystCreateWithoutLabelInput;
}

export interface UserUpdateManyWithoutTemplateLystsInput {
  create?:
    | UserCreateWithoutTemplateLystsInput[]
    | UserCreateWithoutTemplateLystsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTemplateLystsInput[]
    | UserUpdateWithWhereUniqueWithoutTemplateLystsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTemplateLystsInput[]
    | UserUpsertWithWhereUniqueWithoutTemplateLystsInput;
}

export interface CheckLystUpdateManyWithoutLabelInput {
  create?:
    | CheckLystCreateWithoutLabelInput[]
    | CheckLystCreateWithoutLabelInput;
  delete?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  connect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  disconnect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  update?:
    | CheckLystUpdateWithWhereUniqueWithoutLabelInput[]
    | CheckLystUpdateWithWhereUniqueWithoutLabelInput;
  upsert?:
    | CheckLystUpsertWithWhereUniqueWithoutLabelInput[]
    | CheckLystUpsertWithWhereUniqueWithoutLabelInput;
}

export interface UserUpdateWithWhereUniqueWithoutTemplateLystsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTemplateLystsDataInput;
}

export interface CheckLystCreateManyWithoutLabelInput {
  create?:
    | CheckLystCreateWithoutLabelInput[]
    | CheckLystCreateWithoutLabelInput;
  connect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
}

export interface UserUpdateWithoutTemplateLystsDataInput {
  name?: String;
  email?: String;
  avatar?: String;
  checkLysts?: CheckLystUpdateManyWithoutUsersInput;
  itemsCompleted?: Int;
  pro?: Boolean;
  teams?: TeamUpdateManyInput;
}

export type TemplateLystWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface TeamUpdateManyInput {
  create?: TeamCreateInput[] | TeamCreateInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueNestedInput[]
    | TeamUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TeamUpsertWithWhereUniqueNestedInput[]
    | TeamUpsertWithWhereUniqueNestedInput;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface TeamUpdateWithWhereUniqueNestedInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
  email?: String;
}>;

export interface TeamUpdateDataInput {
  name?: String;
  owner?: UserUpdateOneInput;
  admins?: UserUpdateManyInput;
  creators?: UserUpdateManyInput;
  users?: UserUpdateManyInput;
  logo?: String;
  checkLysts?: CheckLystUpdateManyWithoutTeamsInput;
  templateLysts?: TemplateLystUpdateManyWithoutTeamsInput;
  itemsCompleted?: Int;
  activityLogs?: ActivityUpdateManyInput;
}

export interface CheckLystCreateManyWithoutUsersInput {
  create?:
    | CheckLystCreateWithoutUsersInput[]
    | CheckLystCreateWithoutUsersInput;
  connect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
}

export interface CheckLystUpdateManyWithoutTeamsInput {
  create?:
    | CheckLystCreateWithoutTeamsInput[]
    | CheckLystCreateWithoutTeamsInput;
  delete?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  connect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  disconnect?: CheckLystWhereUniqueInput[] | CheckLystWhereUniqueInput;
  update?:
    | CheckLystUpdateWithWhereUniqueWithoutTeamsInput[]
    | CheckLystUpdateWithWhereUniqueWithoutTeamsInput;
  upsert?:
    | CheckLystUpsertWithWhereUniqueWithoutTeamsInput[]
    | CheckLystUpsertWithWhereUniqueWithoutTeamsInput;
}

export interface ActivityCreateManyWithoutCheckLystInput {
  create?:
    | ActivityCreateWithoutCheckLystInput[]
    | ActivityCreateWithoutCheckLystInput;
  connect?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
}

export interface CheckLystUpdateWithWhereUniqueWithoutTeamsInput {
  where: CheckLystWhereUniqueInput;
  data: CheckLystUpdateWithoutTeamsDataInput;
}

export interface TeamCreateManyWithoutCheckLystsInput {
  create?:
    | TeamCreateWithoutCheckLystsInput[]
    | TeamCreateWithoutCheckLystsInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface CheckLystUpdateWithoutTeamsDataInput {
  name?: String;
  items?: ItemUpdateManyInput;
  createdBy?: UserUpdateOneInput;
  users?: UserUpdateManyWithoutCheckLystsInput;
  activityLog?: ActivityUpdateManyWithoutCheckLystInput;
  label?: LabelUpdateOneWithoutCheckLystsInput;
}

export interface TemplateLystCreateWithoutTeamsInput {
  name: String;
  items?: ItemCreateManyInput;
  users?: UserCreateManyWithoutTemplateLystsInput;
}

export interface UserUpdateManyWithoutCheckLystsInput {
  create?:
    | UserCreateWithoutCheckLystsInput[]
    | UserCreateWithoutCheckLystsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutCheckLystsInput[]
    | UserUpdateWithWhereUniqueWithoutCheckLystsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutCheckLystsInput[]
    | UserUpsertWithWhereUniqueWithoutCheckLystsInput;
}

export interface LabelWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  checkLysts_every?: CheckLystWhereInput;
  checkLysts_some?: CheckLystWhereInput;
  checkLysts_none?: CheckLystWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  color?: Color;
  color_not?: Color;
  color_in?: Color[] | Color;
  color_not_in?: Color[] | Color;
  AND?: LabelWhereInput[] | LabelWhereInput;
  OR?: LabelWhereInput[] | LabelWhereInput;
  NOT?: LabelWhereInput[] | LabelWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutCheckLystsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCheckLystsDataInput;
}

export interface LabelSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LabelWhereInput;
  AND?: LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput;
  OR?: LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput;
  NOT?: LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput;
}

export interface UserUpdateWithoutCheckLystsDataInput {
  name?: String;
  email?: String;
  avatar?: String;
  templateLysts?: TemplateLystUpdateManyWithoutUsersInput;
  itemsCompleted?: Int;
  pro?: Boolean;
  teams?: TeamUpdateManyInput;
}

export interface TemplateLystCreateInput {
  name: String;
  items?: ItemCreateManyInput;
  users?: UserCreateManyWithoutTemplateLystsInput;
  teams?: TeamCreateManyWithoutTemplateLystsInput;
}

export interface TemplateLystUpdateManyWithoutUsersInput {
  create?:
    | TemplateLystCreateWithoutUsersInput[]
    | TemplateLystCreateWithoutUsersInput;
  delete?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
  connect?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
  disconnect?: TemplateLystWhereUniqueInput[] | TemplateLystWhereUniqueInput;
  update?:
    | TemplateLystUpdateWithWhereUniqueWithoutUsersInput[]
    | TemplateLystUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | TemplateLystUpsertWithWhereUniqueWithoutUsersInput[]
    | TemplateLystUpsertWithWhereUniqueWithoutUsersInput;
}

export interface CheckLystCreateWithoutLabelInput {
  name: String;
  items?: ItemCreateManyInput;
  createdBy: UserCreateOneInput;
  users?: UserCreateManyWithoutCheckLystsInput;
  activityLog?: ActivityCreateManyWithoutCheckLystInput;
  teams?: TeamCreateManyWithoutCheckLystsInput;
}

export interface TemplateLystUpdateWithWhereUniqueWithoutUsersInput {
  where: TemplateLystWhereUniqueInput;
  data: TemplateLystUpdateWithoutUsersDataInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface TemplateLystUpdateWithoutUsersDataInput {
  name?: String;
  items?: ItemUpdateManyInput;
  teams?: TeamUpdateManyWithoutTemplateLystsInput;
}

export interface CheckLystUpsertWithWhereUniqueWithoutTeamsInput {
  where: CheckLystWhereUniqueInput;
  update: CheckLystUpdateWithoutTeamsDataInput;
  create: CheckLystCreateWithoutTeamsInput;
}

export interface TeamUpdateManyWithoutTemplateLystsInput {
  create?:
    | TeamCreateWithoutTemplateLystsInput[]
    | TeamCreateWithoutTemplateLystsInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutTemplateLystsInput[]
    | TeamUpdateWithWhereUniqueWithoutTemplateLystsInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutTemplateLystsInput[]
    | TeamUpsertWithWhereUniqueWithoutTemplateLystsInput;
}

export interface ItemCreateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface TeamUpdateWithWhereUniqueWithoutTemplateLystsInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutTemplateLystsDataInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface TeamUpdateWithoutTemplateLystsDataInput {
  name?: String;
  owner?: UserUpdateOneInput;
  admins?: UserUpdateManyInput;
  creators?: UserUpdateManyInput;
  users?: UserUpdateManyInput;
  logo?: String;
  checkLysts?: CheckLystUpdateManyWithoutTeamsInput;
  itemsCompleted?: Int;
  activityLogs?: ActivityUpdateManyInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  checkLysts_every?: CheckLystWhereInput;
  checkLysts_some?: CheckLystWhereInput;
  checkLysts_none?: CheckLystWhereInput;
  templateLysts_every?: TemplateLystWhereInput;
  templateLysts_some?: TemplateLystWhereInput;
  templateLysts_none?: TemplateLystWhereInput;
  itemsCompleted?: Int;
  itemsCompleted_not?: Int;
  itemsCompleted_in?: Int[] | Int;
  itemsCompleted_not_in?: Int[] | Int;
  itemsCompleted_lt?: Int;
  itemsCompleted_lte?: Int;
  itemsCompleted_gt?: Int;
  itemsCompleted_gte?: Int;
  pro?: Boolean;
  pro_not?: Boolean;
  teams_every?: TeamWhereInput;
  teams_some?: TeamWhereInput;
  teams_none?: TeamWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ActivityUpdateManyInput {
  create?: ActivityCreateInput[] | ActivityCreateInput;
  delete?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
  connect?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
  disconnect?: ActivityWhereUniqueInput[] | ActivityWhereUniqueInput;
  update?:
    | ActivityUpdateWithWhereUniqueNestedInput[]
    | ActivityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ActivityUpsertWithWhereUniqueNestedInput[]
    | ActivityUpsertWithWhereUniqueNestedInput;
}

export interface CheckLystUpdateWithWhereUniqueWithoutLabelInput {
  where: CheckLystWhereUniqueInput;
  data: CheckLystUpdateWithoutLabelDataInput;
}

export interface ActivityUpdateWithWhereUniqueNestedInput {
  where: ActivityWhereUniqueInput;
  data: ActivityUpdateDataInput;
}

export interface TemplateLystUpsertWithWhereUniqueWithoutTeamsInput {
  where: TemplateLystWhereUniqueInput;
  update: TemplateLystUpdateWithoutTeamsDataInput;
  create: TemplateLystCreateWithoutTeamsInput;
}

export interface ActivityUpdateDataInput {
  type?: ActivityType;
  user?: UserUpdateOneInput;
  checkLyst?: CheckLystUpdateOneWithoutActivityLogInput;
}

export interface LabelCreateOneWithoutCheckLystsInput {
  create?: LabelCreateWithoutCheckLystsInput;
  connect?: LabelWhereUniqueInput;
}

export interface ActivityUpsertWithWhereUniqueNestedInput {
  where: ActivityWhereUniqueInput;
  update: ActivityUpdateDataInput;
  create: ActivityCreateInput;
}

export interface CheckLystUpsertWithoutActivityLogInput {
  update: CheckLystUpdateWithoutActivityLogDataInput;
  create: CheckLystCreateWithoutActivityLogInput;
}

export interface CheckLystUpdateWithoutActivityLogDataInput {
  name?: String;
  items?: ItemUpdateManyInput;
  createdBy?: UserUpdateOneInput;
  users?: UserUpdateManyWithoutCheckLystsInput;
  label?: LabelUpdateOneWithoutCheckLystsInput;
  teams?: TeamUpdateManyWithoutCheckLystsInput;
}

export interface CheckLystUpdateOneWithoutActivityLogInput {
  create?: CheckLystCreateWithoutActivityLogInput;
  update?: CheckLystUpdateWithoutActivityLogDataInput;
  upsert?: CheckLystUpsertWithoutActivityLogInput;
  delete?: Boolean;
  connect?: CheckLystWhereUniqueInput;
}

export interface UserCreateWithoutTemplateLystsInput {
  name: String;
  email: String;
  avatar?: String;
  checkLysts?: CheckLystCreateManyWithoutUsersInput;
  itemsCompleted?: Int;
  pro?: Boolean;
  teams?: TeamCreateManyInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface ItemUpdateInput {
  name?: String;
  completed?: Boolean;
  completedBy?: UserUpdateOneInput;
}

export interface ActivitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivityWhereInput;
  AND?: ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput;
  OR?: ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput;
  NOT?: ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  name: String;
  email: String;
  avatar?: String;
  itemsCompleted: Int;
  pro: Boolean;
}

export interface UserPreviousValues extends Promise<UserPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  avatar: () => Promise<String>;
  itemsCompleted: () => Promise<Int>;
  pro: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  itemsCompleted: () => Promise<AsyncIterator<Int>>;
  pro: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateActivityNode {
  count: Int;
}

export interface AggregateActivity extends Promise<AggregateActivityNode> {
  count: () => Promise<Int>;
}

export interface AggregateActivitySubscription
  extends Promise<AsyncIterator<AggregateActivityNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TeamSubscriptionPayload
  extends Promise<TeamSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Team>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValues>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface ActivityEdgeNode {
  cursor: String;
}

export interface ActivityEdge extends Promise<ActivityEdgeNode> {
  node: <T = Activity>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityEdgeSubscription
  extends Promise<AsyncIterator<ActivityEdgeNode>> {
  node: <T = ActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode> {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>> {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser extends Promise<AggregateUserNode> {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnectionNode {}

export interface UserConnection extends Promise<UserConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<UserEdgeNode>>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<UserEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ActivityConnectionNode {}

export interface ActivityConnection extends Promise<ActivityConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<ActivityEdgeNode>>>() => T;
  aggregate: <T = AggregateActivity>() => T;
}

export interface ActivityConnectionSubscription
  extends Promise<AsyncIterator<ActivityConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<ActivityEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateActivitySubscription>() => T;
}

export interface TeamEdgeNode {
  cursor: String;
}

export interface TeamEdge extends Promise<TeamEdgeNode> {
  node: <T = Team>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdgeNode>> {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TemplateLystNode {
  id: ID_Output;
  name: String;
}

export interface TemplateLyst extends Promise<TemplateLystNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  items: <T = Promise<Array<ItemNode>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  users: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  teams: <T = Promise<Array<TeamNode>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface TemplateLystSubscription
  extends Promise<AsyncIterator<TemplateLystNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  items: <T = Promise<AsyncIterator<Array<ItemSubscription>>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  users: <T = Promise<AsyncIterator<Array<UserSubscription>>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  teams: <T = Promise<AsyncIterator<Array<TeamSubscription>>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface AggregateTemplateLystNode {
  count: Int;
}

export interface AggregateTemplateLyst
  extends Promise<AggregateTemplateLystNode> {
  count: () => Promise<Int>;
}

export interface AggregateTemplateLystSubscription
  extends Promise<AsyncIterator<AggregateTemplateLystNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityNode {
  id: ID_Output;
  type: ActivityType;
}

export interface Activity extends Promise<ActivityNode> {
  id: () => Promise<ID_Output>;
  type: () => Promise<ActivityType>;
  user: <T = User>() => T;
  checkLyst: <T = CheckLyst>() => T;
}

export interface ActivitySubscription
  extends Promise<AsyncIterator<ActivityNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ActivityType>>;
  user: <T = UserSubscription>() => T;
  checkLyst: <T = CheckLystSubscription>() => T;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode> {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>> {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActivitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ActivitySubscriptionPayload
  extends Promise<ActivitySubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Activity>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityPreviousValues>() => T;
}

export interface ActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivitySubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityPreviousValuesSubscription>() => T;
}

export interface TemplateLystConnectionNode {}

export interface TemplateLystConnection
  extends Promise<TemplateLystConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TemplateLystEdgeNode>>>() => T;
  aggregate: <T = AggregateTemplateLyst>() => T;
}

export interface TemplateLystConnectionSubscription
  extends Promise<AsyncIterator<TemplateLystConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<TemplateLystEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateTemplateLystSubscription>() => T;
}

export interface ActivityPreviousValuesNode {
  id: ID_Output;
  type: ActivityType;
}

export interface ActivityPreviousValues
  extends Promise<ActivityPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  type: () => Promise<ActivityType>;
}

export interface ActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ActivityType>>;
}

export interface LabelEdgeNode {
  cursor: String;
}

export interface LabelEdge extends Promise<LabelEdgeNode> {
  node: <T = Label>() => T;
  cursor: () => Promise<String>;
}

export interface LabelEdgeSubscription
  extends Promise<AsyncIterator<LabelEdgeNode>> {
  node: <T = LabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CheckLystNode {
  id: ID_Output;
  name: String;
}

export interface CheckLyst extends Promise<CheckLystNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  items: <T = Promise<Array<ItemNode>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  createdBy: <T = User>() => T;
  users: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  activityLog: <T = Promise<Array<ActivityNode>>>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  label: <T = Label>() => T;
  teams: <T = Promise<Array<TeamNode>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface CheckLystSubscription
  extends Promise<AsyncIterator<CheckLystNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  items: <T = Promise<AsyncIterator<Array<ItemSubscription>>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  createdBy: <T = UserSubscription>() => T;
  users: <T = Promise<AsyncIterator<Array<UserSubscription>>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  activityLog: <T = Promise<AsyncIterator<Array<ActivitySubscription>>>>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  label: <T = LabelSubscription>() => T;
  teams: <T = Promise<AsyncIterator<Array<TeamSubscription>>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface UserNode {
  id: ID_Output;
  name: String;
  email: String;
  avatar?: String;
  itemsCompleted: Int;
  pro: Boolean;
}

export interface User extends Promise<UserNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  avatar: () => Promise<String>;
  checkLysts: <T = Promise<Array<CheckLystNode>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  templateLysts: <T = Promise<Array<TemplateLystNode>>>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  itemsCompleted: () => Promise<Int>;
  pro: () => Promise<Boolean>;
  teams: <T = Promise<Array<TeamNode>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface UserSubscription extends Promise<AsyncIterator<UserNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  checkLysts: <T = Promise<AsyncIterator<Array<CheckLystSubscription>>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  templateLysts: <T = Promise<AsyncIterator<Array<TemplateLystSubscription>>>>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  itemsCompleted: () => Promise<AsyncIterator<Int>>;
  pro: () => Promise<AsyncIterator<Boolean>>;
  teams: <T = Promise<AsyncIterator<Array<TeamSubscription>>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface CheckLystSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CheckLystSubscriptionPayload
  extends Promise<CheckLystSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = CheckLyst>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CheckLystPreviousValues>() => T;
}

export interface CheckLystSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CheckLystSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CheckLystSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CheckLystPreviousValuesSubscription>() => T;
}

export interface ItemEdgeNode {
  cursor: String;
}

export interface ItemEdge extends Promise<ItemEdgeNode> {
  node: <T = Item>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdgeNode>> {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CheckLystPreviousValuesNode {
  id: ID_Output;
  name: String;
}

export interface CheckLystPreviousValues
  extends Promise<CheckLystPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CheckLystPreviousValuesSubscription
  extends Promise<AsyncIterator<CheckLystPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCheckLystNode {
  count: Int;
}

export interface AggregateCheckLyst extends Promise<AggregateCheckLystNode> {
  count: () => Promise<Int>;
}

export interface AggregateCheckLystSubscription
  extends Promise<AsyncIterator<AggregateCheckLystNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamNode {
  id: ID_Output;
  name: String;
  logo?: String;
  itemsCompleted?: Int;
}

export interface Team extends Promise<TeamNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  owner: <T = User>() => T;
  admins: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  creators: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  users: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  logo: () => Promise<String>;
  checkLysts: <T = Promise<Array<CheckLystNode>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  templateLysts: <T = Promise<Array<TemplateLystNode>>>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  itemsCompleted: () => Promise<Int>;
  activityLogs: <T = Promise<Array<ActivityNode>>>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface TeamSubscription extends Promise<AsyncIterator<TeamNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
  admins: <T = Promise<AsyncIterator<Array<UserSubscription>>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  creators: <T = Promise<AsyncIterator<Array<UserSubscription>>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  users: <T = Promise<AsyncIterator<Array<UserSubscription>>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  logo: () => Promise<AsyncIterator<String>>;
  checkLysts: <T = Promise<AsyncIterator<Array<CheckLystSubscription>>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  templateLysts: <T = Promise<AsyncIterator<Array<TemplateLystSubscription>>>>(
    args?: {
      where?: TemplateLystWhereInput;
      orderBy?: TemplateLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  itemsCompleted: () => Promise<AsyncIterator<Int>>;
  activityLogs: <T = Promise<AsyncIterator<Array<ActivitySubscription>>>>(
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
}

export interface CheckLystConnectionNode {}

export interface CheckLystConnection extends Promise<CheckLystConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<CheckLystEdgeNode>>>() => T;
  aggregate: <T = AggregateCheckLyst>() => T;
}

export interface CheckLystConnectionSubscription
  extends Promise<AsyncIterator<CheckLystConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<CheckLystEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateCheckLystSubscription>() => T;
}

export interface ItemSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ItemSubscriptionPayload
  extends Promise<ItemSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Item>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValues>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface AggregateTeamNode {
  count: Int;
}

export interface AggregateTeam extends Promise<AggregateTeamNode> {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeamNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemPreviousValuesNode {
  id: ID_Output;
  name: String;
  completed: Boolean;
}

export interface ItemPreviousValues extends Promise<ItemPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  completed: () => Promise<Boolean>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
}

export interface TemplateLystEdgeNode {
  cursor: String;
}

export interface TemplateLystEdge extends Promise<TemplateLystEdgeNode> {
  node: <T = TemplateLyst>() => T;
  cursor: () => Promise<String>;
}

export interface TemplateLystEdgeSubscription
  extends Promise<AsyncIterator<TemplateLystEdgeNode>> {
  node: <T = TemplateLystSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LabelNode {
  id: ID_Output;
  name: String;
  color: Color;
}

export interface Label extends Promise<LabelNode> {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  checkLysts: <T = Promise<Array<CheckLystNode>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  name: () => Promise<String>;
  color: () => Promise<Color>;
}

export interface LabelSubscription extends Promise<AsyncIterator<LabelNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  checkLysts: <T = Promise<AsyncIterator<Array<CheckLystSubscription>>>>(
    args?: {
      where?: CheckLystWhereInput;
      orderBy?: CheckLystOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | Object
  ) => T;
  name: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<Color>>;
}

export interface AggregateLabelNode {
  count: Int;
}

export interface AggregateLabel extends Promise<AggregateLabelNode> {
  count: () => Promise<Int>;
}

export interface AggregateLabelSubscription
  extends Promise<AsyncIterator<AggregateLabelNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LabelSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LabelSubscriptionPayload
  extends Promise<LabelSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Label>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LabelPreviousValues>() => T;
}

export interface LabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LabelSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LabelPreviousValuesSubscription>() => T;
}

export interface AggregateItemNode {
  count: Int;
}

export interface AggregateItem extends Promise<AggregateItemNode> {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItemNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LabelPreviousValuesNode {
  id: ID_Output;
  name: String;
  color: Color;
}

export interface LabelPreviousValues extends Promise<LabelPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  color: () => Promise<Color>;
}

export interface LabelPreviousValuesSubscription
  extends Promise<AsyncIterator<LabelPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<Color>>;
}

export interface CheckLystEdgeNode {
  cursor: String;
}

export interface CheckLystEdge extends Promise<CheckLystEdgeNode> {
  node: <T = CheckLyst>() => T;
  cursor: () => Promise<String>;
}

export interface CheckLystEdgeSubscription
  extends Promise<AsyncIterator<CheckLystEdgeNode>> {
  node: <T = CheckLystSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TeamConnectionNode {}

export interface TeamConnection extends Promise<TeamConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TeamEdgeNode>>>() => T;
  aggregate: <T = AggregateTeam>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TeamEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface ItemNode {
  id: ID_Output;
  name: String;
  completed: Boolean;
}

export interface Item extends Promise<ItemNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  completed: () => Promise<Boolean>;
  completedBy: <T = User>() => T;
}

export interface ItemSubscription extends Promise<AsyncIterator<ItemNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
  completedBy: <T = UserSubscription>() => T;
}

export interface TemplateLystPreviousValuesNode {
  id: ID_Output;
  name: String;
}

export interface TemplateLystPreviousValues
  extends Promise<TemplateLystPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TemplateLystPreviousValuesSubscription
  extends Promise<AsyncIterator<TemplateLystPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TemplateLystSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TemplateLystSubscriptionPayload
  extends Promise<TemplateLystSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = TemplateLyst>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TemplateLystPreviousValues>() => T;
}

export interface TemplateLystSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TemplateLystSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TemplateLystSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TemplateLystPreviousValuesSubscription>() => T;
}

export interface TeamPreviousValuesNode {
  id: ID_Output;
  name: String;
  logo?: String;
  itemsCompleted?: Int;
}

export interface TeamPreviousValues extends Promise<TeamPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  logo: () => Promise<String>;
  itemsCompleted: () => Promise<Int>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  itemsCompleted: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode> {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>> {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemConnectionNode {}

export interface ItemConnection extends Promise<ItemConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<ItemEdgeNode>>>() => T;
  aggregate: <T = AggregateItem>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<ItemEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface LabelConnectionNode {}

export interface LabelConnection extends Promise<LabelConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<LabelEdgeNode>>>() => T;
  aggregate: <T = AggregateLabel>() => T;
}

export interface LabelConnectionSubscription
  extends Promise<AsyncIterator<LabelConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<LabelEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateLabelSubscription>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Type Defs
 */

export const Prisma = makePrismaBindingClass<BindingConstructor<Prisma>>({
  typeDefs,
  endpoint: "http://localhost:4466"
});
export const prisma = new Prisma();
